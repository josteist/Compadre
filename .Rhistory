#' A function to generate sensible initial values for MCMC estimation.
#'
#' getInits generates initial values for a complex CMR model. Essentially the global parameters (mean rates) are estimated optimizing the probability density function, assuming all random effects are 0. Then each random effect is estimated independently, assuming all other random effects are 0. This is not proper optimization, but work reasonably well for initial values.
#'
#' @param cmrModel A CMR model structure with 1 clade.
#' @return The function returns relatively decent initial values for MCMC estimation.
#' @export
#' @examples mod1 <- make.BayesCMR(Obs)
#' x0 <- getInit(mod1)
#' fit <- MCMC_CMR(mod1,x0=x0)
getInit <- function(cmrModel){
# THis function will generate probable initial values for the MCMC chain.
# The main parameters will be estimated by optim ignoring the random effects afterwhich all the RE will be optimzed independently (1 dimension at a time).
# Change to also include drivers, but NOT variances.
if (length(cmrModel$inx)==2){
# it's a 2-clade omdel
x_1 <- c(optim(c(-1,-1.1,-1.2),function(x){-cmrModel$Clade1Mod$probfun(c(x[1],x[2],x[3],rep(0,cmrModel$Clade1Mod$npar-3)))})$par,
rep(0,cmrModel$Clade1Mod$npar-3))
xix <- sample(unlist(cmrModel$Clade1Mod$inx[5:7]))
if (length(xix)>0){
xres <- sapply(xix,function(jj){
optim(0,function(yy){-cmrModel$Clade1Mod$probfun(c(x_1[1:(jj-1)],yy,x_1[(jj+1):cmrModel$Clade1Mod$npar]))},
method='Brent',lower=-10,upper=10)$par})
x_1[xix]=xres;
}
x_2 <- c(optim(c(-1,-1.1,-1.2),function(x){-cmrModel$Clade2Mod$probfun(c(x[1],x[2],x[3],rep(0,cmrModel$Clade2Mod$npar-3)))})$par,
rep(0,cmrModel$Clade2Mod$npar-3))
xix <- sample(unlist(cmrModel$Clade2Mod$inx[5:7]))
if (length(xix)>0){
xres <- sapply(xix,function(jj){
optim(0,function(yy){-cmrModel$Clade2Mod$probfun(c(x_2[1:(jj-1)],yy,x_2[(jj+1):cmrModel$Clade2Mod$npar]))},
method='Brent',lower=-10,upper=10)$par})
x_2[xix]=xres;
}
x0 = c(x_1,x_2);
} else {
if (cmrModel$npar>3){
x <- c(optim(c(-1,-1.1,-1.2),function(x){-cmrModel$probfun(c(x[1],x[2],x[3],rep(0,cmrModel$npar-3)))})$par,
rep(0,cmrModel$npar-3))
xix <- sample(unlist(cmrModel$inx[5:7]))
if (length(xix)>0){
xres <- sapply(xix,function(jj){
optim(0,function(yy){-cmrModel$probfun(c(x[1:(jj-1)],yy,x[(jj+1):cmrModel$npar]))},
method='Brent',lower=-10,upper=10)$par})
x[xix]=xres;
}
} else {
x <- optim(c(-1,-1.1,-1.2),function(x){-cmrModel$probfun(x)})$par
}
}
return(x0=x)
}
j <- getInit(m2a)
j
getInit(m2a$Clade1Mod)
getInit(m2a$Clade2Mod)
#' A function to generate sensible initial values for MCMC estimation.
#'
#' getInits generates initial values for a complex CMR model. Essentially the global parameters (mean rates) are estimated optimizing the probability density function, assuming all random effects are 0. Then each random effect is estimated independently, assuming all other random effects are 0. This is not proper optimization, but work reasonably well for initial values.
#'
#' @param cmrModel A CMR model structure with 1 clade.
#' @return The function returns relatively decent initial values for MCMC estimation.
#' @export
#' @examples mod1 <- make.BayesCMR(Obs)
#' x0 <- getInit(mod1)
#' fit <- MCMC_CMR(mod1,x0=x0)
getInit2 <- function(cmrModel){
# THis function will generate probable initial values for the MCMC chain.
# The main parameters will be estimated by optim ignoring the random effects afterwhich all the RE will be optimzed independently (1 dimension at a time).
# Change to also include drivers, but NOT variances.
if (length(cmrModel$inx)==2){
# it's a 2-clade omdel
x_1 <- c(optim(c(-1,-1.1,-1.2),function(x){-cmrModel$Clade1Mod$probfun(c(x[1],x[2],x[3],rep(0,cmrModel$Clade1Mod$npar-3)))})$par,
rep(0,cmrModel$Clade1Mod$npar-3))
xix <- sample(unlist(cmrModel$Clade1Mod$inx[5:7]))
if (length(xix)>0){
xres <- sapply(xix,function(jj){
optim(0,function(yy){-cmrModel$Clade1Mod$probfun(c(x_1[1:(jj-1)],yy,x_1[(jj+1):cmrModel$Clade1Mod$npar]))},
method='Brent',lower=-10,upper=10)$par})
x_1[xix]=xres;
}
x_2 <- c(optim(c(-1,-1.1,-1.2),function(x){-cmrModel$Clade2Mod$probfun(c(x[1],x[2],x[3],rep(0,cmrModel$Clade2Mod$npar-3)))})$par,
rep(0,cmrModel$Clade2Mod$npar-3))
xix <- sample(unlist(cmrModel$Clade2Mod$inx[5:7]))
if (length(xix)>0){
xres <- sapply(xix,function(jj){
optim(0,function(yy){-cmrModel$Clade2Mod$probfun(c(x_2[1:(jj-1)],yy,x_2[(jj+1):cmrModel$Clade2Mod$npar]))},
method='Brent',lower=-10,upper=10)$par})
x_2[xix]=xres;
}
x0 = c(x_1,x_2);
} else {
if (cmrModel$npar>3){
x <- c(optim(c(-1,-1.1,-1.2),function(x){-cmrModel$probfun(c(x[1],x[2],x[3],rep(0,cmrModel$npar-3)))})$par,
rep(0,cmrModel$npar-3))
xix <- sample(unlist(cmrModel$inx[5:7]))
if (length(xix)>0){
xres <- sapply(xix,function(jj){
optim(0,function(yy){-cmrModel$probfun(c(x[1:(jj-1)],yy,x[(jj+1):cmrModel$npar]))},
method='Brent',lower=-10,upper=10)$par})
x[xix]=xres;
}
} else {
x <- optim(c(-1,-1.1,-1.2),function(x){-cmrModel$probfun(x)})$par
}
}
return(x0=x)
}
getInit2(m2a)
length(m2a$inx)
cmrModel = m2a
x_1 <- c(optim(c(-1,-1.1,-1.2),function(x){-cmrModel$Clade1Mod$probfun(c(x[1],x[2],x[3],rep(0,cmrModel$Clade1Mod$npar-3)))})$par,
rep(0,cmrModel$Clade1Mod$npar-3))
xix <- sample(unlist(cmrModel$Clade1Mod$inx[5:7]))
if (length(xix)>0){
xres <- sapply(xix,function(jj){
optim(0,function(yy){-cmrModel$Clade1Mod$probfun(c(x_1[1:(jj-1)],yy,x_1[(jj+1):cmrModel$Clade1Mod$npar]))},
method='Brent',lower=-10,upper=10)$par})
x_1[xix]=xres;
}
x_2 <- c(optim(c(-1,-1.1,-1.2),function(x){-cmrModel$Clade2Mod$probfun(c(x[1],x[2],x[3],rep(0,cmrModel$Clade2Mod$npar-3)))})$par,
rep(0,cmrModel$Clade2Mod$npar-3))
xix <- sample(unlist(cmrModel$Clade2Mod$inx[5:7]))
if (length(xix)>0){
xres <- sapply(xix,function(jj){
optim(0,function(yy){-cmrModel$Clade2Mod$probfun(c(x_2[1:(jj-1)],yy,x_2[(jj+1):cmrModel$Clade2Mod$npar]))},
method='Brent',lower=-10,upper=10)$par})
x_2[xix]=xres;
}
x0 = c(x_1,x_2);
x0
(length(cmrModel$inx)==2)
#' A function to generate sensible initial values for MCMC estimation.
#'
#' getInits generates initial values for a complex CMR model. Essentially the global parameters (mean rates) are estimated optimizing the probability density function, assuming all random effects are 0. Then each random effect is estimated independently, assuming all other random effects are 0. This is not proper optimization, but work reasonably well for initial values.
#'
#' @param cmrModel A CMR model structure with 1 clade.
#' @return The function returns relatively decent initial values for MCMC estimation.
#' @export
#' @examples mod1 <- make.BayesCMR(Obs)
#' x0 <- getInit(mod1)
#' fit <- MCMC_CMR(mod1,x0=x0)
getInit <- function(cmrModel){
# THis function will generate probable initial values for the MCMC chain.
# The main parameters will be estimated by optim ignoring the random effects afterwhich all the RE will be optimzed independently (1 dimension at a time).
# Change to also include drivers, but NOT variances.
if (length(cmrModel$inx)==2){
# it's a 2-clade omdel
x_1 <- c(optim(c(-1,-1.1,-1.2),function(x){-cmrModel$Clade1Mod$probfun(c(x[1],x[2],x[3],rep(0,cmrModel$Clade1Mod$npar-3)))})$par,
rep(0,cmrModel$Clade1Mod$npar-3))
xix <- sample(unlist(cmrModel$Clade1Mod$inx[5:7]))
if (length(xix)>0){
xres <- sapply(xix,function(jj){
optim(0,function(yy){-cmrModel$Clade1Mod$probfun(c(x_1[1:(jj-1)],yy,x_1[(jj+1):cmrModel$Clade1Mod$npar]))},
method='Brent',lower=-10,upper=10)$par})
x_1[xix]=xres;
}
x_2 <- c(optim(c(-1,-1.1,-1.2),function(x){-cmrModel$Clade2Mod$probfun(c(x[1],x[2],x[3],rep(0,cmrModel$Clade2Mod$npar-3)))})$par,
rep(0,cmrModel$Clade2Mod$npar-3))
xix <- sample(unlist(cmrModel$Clade2Mod$inx[5:7]))
if (length(xix)>0){
xres <- sapply(xix,function(jj){
optim(0,function(yy){-cmrModel$Clade2Mod$probfun(c(x_2[1:(jj-1)],yy,x_2[(jj+1):cmrModel$Clade2Mod$npar]))},
method='Brent',lower=-10,upper=10)$par})
x_2[xix]=xres;
}
x = c(x_1,x_2);
} else {
if (cmrModel$npar>3){
x <- c(optim(c(-1,-1.1,-1.2),function(x){-cmrModel$probfun(c(x[1],x[2],x[3],rep(0,cmrModel$npar-3)))})$par,
rep(0,cmrModel$npar-3))
xix <- sample(unlist(cmrModel$inx[5:7]))
if (length(xix)>0){
xres <- sapply(xix,function(jj){
optim(0,function(yy){-cmrModel$probfun(c(x[1:(jj-1)],yy,x[(jj+1):cmrModel$npar]))},
method='Brent',lower=-10,upper=10)$par})
x[xix]=xres;
}
} else {
x <- optim(c(-1,-1.1,-1.2),function(x){-cmrModel$probfun(x)})$par
}
}
return(x0=x)
}
getInit(m2a)
setwd('C:/Users/josteist/Documents/R/Compadre')
document()
library(devtools)
setwd('C:/Users/josteist/Documents/R/Compadre')
document()
setwd('C:/Users/josteist/Documents/R')
install('Compadre')
version
S1 <- sim_BD_func_v2(spec = function(t,n){0.3-log(n)*0.03},ext=function(t,n){0.1},dt_ints=rep(1,13))
plotN_sim(S1)
m1 <- make_BayesCMR_halfnormpri(S1$FosRec>0,spec=~time,ext=~time,samp=~time,priorsHalfNorm_Var = 1)
m2 <- make_BayesCMR_halfnormpri(S1$FosRec>0,spec=~time+div, ext=~time,samp=~time,priorsHalfNorm_Var = 1)
x01 <- getInit(m1)
x02 <- getInit(m2)
x01
x02
library(parallel)
cl <- makeCluster(6)
x01 <- getInit(m1)
x02 <- getInit(m2)
clusterEvalQ(cl,library(Compadre))
clusterExport(cl,c("m1","m2","x01","x02"))
myParlfun1 <- function(vmin){
fit<-MCMC_CMR(m1,x0=x01*runif(m1$npar,min=0.9,max=1.1),niter=4e5,noblc = 100,
vmin=vmin,cvstp=diag(1e-3,m1$npar))}
myParlfun2 <- function(vmin){
fit<-MCMC_CMR(m2,x0=x02*runif(m2$npar,min=0.9,max=1.1),niter=4e5,noblc = 100,
vmin=vmin,cvstp=diag(1e-3,m2$npar))}
fitsL1 <- parLapply(cl,10^(seq(-8,-3,by=1)),myParlfun1)
fitsL1[[1]]
checkchains(fitsL1[[1]])
checkchains(fitsL1[[2]])
checkchains(fitsL1[[3]])
checkchains(fitsL1[[4]])
checkchains(fitsL1[[5]])
m1 <- make_BayesCMR(S1$FosRec>0,spec=~time,ext=~time,samp=~time)
m2 <- make_BayesCMR(S1$FosRec>0,spec=~time+div, ext=~time,samp=~time)
x01 <- getInit(m1)
x02 <- getInit(m2)
clusterEvalQ(cl,library(Compadre))
clusterExport(cl,c("m1","m2","x01","x02"))
myParlfun1 <- function(vmin){
fit<-MCMC_CMR(m1,x0=x01*runif(m1$npar,min=0.9,max=1.1),niter=4e5,noblc = 100,
vmin=vmin,cvstp=diag(1e-3,m1$npar))}
myParlfun2 <- function(vmin){
fit<-MCMC_CMR(m2,x0=x02*runif(m2$npar,min=0.9,max=1.1),niter=4e5,noblc = 100,
vmin=vmin,cvstp=diag(1e-3,m2$npar))}
fitsL1 <- parLapply(cl,10^(seq(-8,-3,by=1)),myParlfun1)
checkchains(fitsL1[[1]])
checkchains(fitsL1[[2]])
checkchains(fitsL1[[3]])
checkchains(fitsL1[[4]])
checkchains(fitsL1[[5]])
summary(fitsL1[[1]])
summary(fitsL1[[2]])
summary(fitsL1[[3]])
summary(fitsL1[[3]])
summary(fitsL1[[4]])
t <- sapply(1:6,function(ii){plot(fitsL[[ii]],drawplot=FALSE)$ExtRates})
t <- sapply(1:6,function(ii){plot(fitsL1[[ii]],drawplot=FALSE)$ExtRates})
par(mfrow=c(2,3))
for (jj in 1:6){
boxplot(t(matrix(t[,jj],nrow=17)),log='y',ylab='Extrates')
}
t <- sapply(1:6,function(ii){plot(fitsL1[[ii]],drawplot=FALSE)$SpecRates})
par(mfrow=c(2,3))
for (jj in 1:6){
boxplot(t(matrix(t[,jj],nrow=17)),log='y',ylab='Extrates')
}
dim(t)
dim(S1$FosRec)
par(mfrow=c(2,3))
for (jj in 1:6){
boxplot(t(matrix(t[,jj],nrow=13)),log='y',ylab='Extrates')
}
dim(t)
par(mfrow=c(2,3))
for (jj in 1:6){
boxplot(t(matrix(t[,jj],nrow=12)),log='y',ylab='Extrates')
}
t <- sapply(1:6,function(ii){plot(fitsL1[[ii]],drawplot=FALSE)$SpecRates})
par(mfrow=c(2,3))
for (jj in 1:6){
boxplot(t(matrix(t[,jj],nrow=12)),log='y',ylab='Extrates')
}
matplot(sapply(1:6,function(ii){apply(t(matrix(t[,ii],nrow=17)),2,median)}),type="l")
matplot(sapply(1:6,function(ii){apply(t(matrix(t[,ii],nrow=12)),2,median)}),type="l")
S1 <- sim_BD_func_v2(spec = function(t,n){0.3-log(n)*0.03},ext=function(t,n){0.1},dt_ints=rep(1,13),n_init = 500)
plotN_sim(S1)
S1 <- sim_BD_func_v2(spec = function(t,n){0.3-log(n)*0.03},ext=function(t,n){0.1},dt_ints=rep(1,13),n_init = 50)
plotN_sim(S1)
S1 <- sim_BD_func_v2(spec = function(t,n){0.5-log(n)*0.05},ext=function(t,n){0.1},dt_ints=rep(1,13),n_init = 50)
plotN_sim(S1)
log(100)
S1 <- sim_BD_func_v2(spec = function(t,n){0.5-log(n)*0.1},ext=function(t,n){0.1},dt_ints=rep(1,13),n_init = 50)
plotN_sim(S1)
log(50)
S1 <- sim_BD_func_v2(spec = function(t,n){0.7-log(n)*0.1},ext=function(t,n){0.1},dt_ints=rep(1,13),n_init = 50)
plotN_sim(S1)
S1 <- sim_BD_func_v2(spec = function(t,n){0.6-log(n)*0.1},ext=function(t,n){0.1},dt_ints=rep(1,13),n_init = 50)
plotN_sim(S1)
m1 <- make_BayesCMR(S1$FosRec>0,spec=~time,ext=~time,samp=~time)
m2 <- make_BayesCMR(S1$FosRec>0,spec=~time+div, ext=~time,samp=~time)
x01 <- getInit(m1)
x02 <- getInit(m2)
clusterEvalQ(cl,library(Compadre))
clusterExport(cl,c("m1","m2","x01","x02"))
myParlfun1 <- function(vmin){
fit<-MCMC_CMR(m1,x0=x01*runif(m1$npar,min=0.9,max=1.1),niter=4e5,noblc = 100,
vmin=vmin,cvstp=diag(1e-3,m1$npar))}
myParlfun2 <- function(vmin){
fit<-MCMC_CMR(m2,x0=x02*runif(m2$npar,min=0.9,max=1.1),niter=4e5,noblc = 100,
vmin=vmin,cvstp=diag(1e-3,m2$npar))}
fitsL1 <- parLapply(cl,10^(seq(-8,-3,by=1)),myParlfun1)
t <- sapply(1:6,function(ii){plot(fitsL1[[ii]],drawplot=FALSE)$SpecRates})
par(mfrow=c(2,3))
for (jj in 1:6){
boxplot(t(matrix(t[,jj],nrow=12)),log='y',ylab='Extrates')
}
fitsL2 <- parLapply(cl,10^(seq(-8,-3,by=1)),myParlfun2)
t <- sapply(1:6,function(ii){plot(fitsL2[[ii]],drawplot=FALSE)$SpecRates})
par(mfrow=c(2,3))
for (jj in 1:6){
boxplot(t(matrix(t[,jj],nrow=12)),log='y',ylab='Extrates')
}
checkchains(fitsL2[[1]])
checkchains(fitsL2[[2]])
checkchains(fitsL2[[3]])
bml1 <- sapply(1:6,function(ii){doBML(fitsL1[[ii]])$logBML})
bml2 <- sapply(1:6,function(ii){doBML(fitsL2[[ii]])$logBML})
bml1
bml2
summary(fitsL2[[1]])
plotN_sim(S1)
S1 <- sim_BD_func_v2(spec = function(t,n){0.6-log(n)*0.13},ext=function(t,n){0.1},dt_ints=rep(1,13),n_init = 50)
plotN_sim(S1)
S1 <- sim_BD_func_v2(spec = function(t,n){0.6-log(n)*0.1},ext=function(t,n){0.08},dt_ints=rep(1,13),n_init = 50)
plotN_sim(S1)
S1 <- sim_BD_func_v2(spec = function(t,n){0.6-log(n)*0.14},ext=function(t,n){0.08},dt_ints=rep(1,13),n_init = 50)
plotN_sim(S1)
S1 <- sim_BD_func_v2(spec = function(t,n){0.6-log(n)*0.14},ext=function(t,n){0.04},dt_ints=rep(1,13),n_init = 50)
plotN_sim(S1)
S1 <- sim_BD_func_v2(spec = function(t,n){0.6-log(n)*0.14},ext=function(t,n){0.04},dt_ints=rep(1,13),n_init = 10)
plotN_sim(S1)
S1 <- sim_BD_func_v2(spec = function(t,n){0.6-log(n)*0.14},ext=function(t,n){0.04},dt_ints=rep(1,13),n_init = 20)
plotN_sim(S1)
S1 <- sim_BD_func_v2(spec = function(t,n){0.6-log(n)*0.014},ext=function(t,n){0.04},dt_ints=rep(1,13),n_init = 220)
plotN_sim(S1)
S1 <- sim_BD_func_v2(spec = function(t,n){0.6-log(n)*0.05},ext=function(t,n){0.08},dt_ints=rep(1,13),n_init = 220)
plotN_sim(S1)
S1 <- sim_BD_func_v2(spec = function(t,n){0.6-log(n)*0.075},ext=function(t,n){0.08},dt_ints=rep(1,13),n_init = 220)
plotN_sim(S1)
S1 <- sim_BD_func_v2(spec = function(t,n){0.6-log(n)*0.085},ext=function(t,n){0.08},dt_ints=rep(1,13),n_init = 220)
plotN_sim(S1)
S1 <- sim_BD_func_v2(spec = function(t,n){0.6-log(n)*0.095},ext=function(t,n){0.08},dt_ints=rep(1,13),n_init = 220)
plotN_sim(S1)
log(400)
log(10)/log(500)
log(10-500)
log(10)-log(500)
log(500)/log(400)
log(500)/log(500)
S1 <- sim_BD_func_v2(spec = function(t,n){1.2*(1 -log(n)/log(400))},ext=function(t,n){0.08},dt_ints=rep(1,13),n_init = 220)
plotN_sim(S1)
S1 <- sim_BD_func_v2(spec = function(t,n){1.2*(1 -log(n)/log(400))},ext=function(t,n){0.08},dt_ints=rep(1,13),n_init = 20)
plotN_sim(S1)
S1 <- sim_BD_func_v2(spec = function(t,n){1.2*(1 -log(n)/log(300))},ext=function(t,n){0.08},dt_ints=rep(1,12),n_init = 20)
plotN_sim(S1)
S1 <- sim_BD_func_v2(spec = function(t,n){1.4*(1 -log(n)/log(300))},ext=function(t,n){0.08},dt_ints=rep(1,12),n_init = 20)
plotN_sim(S1)
m1 <- make_BayesCMR(S1$FosRec>0,spec=~time,ext=~time,samp=~time)
m2 <- make_BayesCMR(S1$FosRec>0,spec=~time+div, ext=~time,samp=~time)
stopCluster(cl)
cl <- makeCluster(6)
x01 <- getInit(m1)
x02 <- getInit(m2)
clusterEvalQ(cl,library(Compadre))
clusterExport(cl,c("m1","m2","x01","x02"))
myParlfun1 <- function(vmin){
fit<-MCMC_CMR(m1,x0=x01*runif(m1$npar,min=0.9,max=1.1),niter=4e5,noblc = 100,
vmin=vmin,cvstp=diag(1e-3,m1$npar))}
myParlfun2 <- function(vmin){
fit<-MCMC_CMR(m2,x0=x02*runif(m2$npar,min=0.9,max=1.1),niter=4e5,noblc = 100,
vmin=vmin,cvstp=diag(1e-3,m2$npar))}
fitsL1 <- parLapply(cl,10^(seq(-8,-3,by=1)),myParlfun1)
fitsL2 <- parLapply(cl,10^(seq(-8,-3,by=1)),myParlfun2)
t <- sapply(1:6,function(ii){plot(fitsL2[[ii]],drawplot=FALSE)$SpecRates})
par(mfrow=c(2,3))
for (jj in 1:6){
boxplot(t(matrix(t[,jj],nrow=12)),log='y',ylab='Extrates')
}
dim(m1$Obs)
dim(t)
for (jj in 1:6){
boxplot(t(matrix(t[,jj],nrow=11)),log='y',ylab='Extrates')
}
checkchains(fitsL1[[1]])
checkchains(fitsL1[[6]])
checkchains(fitsL1[[3]])
checkchains(fitsL2[[3]])
summary(fitsL2[[1]])
bml1 <- sapply(1:6,function(ii){doBML(fitsL1[[ii]])$logBML})
bml2 <- sapply(1:6,function(ii){doBML(fitsL2[[ii]])$logBML})
bml1
bml2
matplot(sapply(1:6,function(ii){apply(t(matrix(t[,ii],nrow=12)),2,median)}),type="l")
t <- sapply(1:6,function(ii){plot(fitsL2[[ii]],drawplot=FALSE)$SpecRates})
matplot(sapply(1:6,function(ii){apply(t(matrix(t[,ii],nrow=11)),2,median)}),type="l")
S1$dts
m3 <- make_BayesCMR(S1$FosRec>0,spec=~time+d1, ext=~time,samp=~time,data=mockdata)
m4 <- make_BayesCMR(S1$FosRec>0,spec=~time+d2, ext=~time,samp=~time,data=mockdata)
mockdata <- data.frame(d1 = runif(length(S1$dts)),
d2 = seq(-1,1,length.out=length(S1$dts)))
m3 <- make_BayesCMR(S1$FosRec>0,spec=~time+d1, ext=~time,samp=~time,data=mockdata)
m4 <- make_BayesCMR(S1$FosRec>0,spec=~time+d2, ext=~time,samp=~time,data=mockdata)
x03 <- getInit(m3)
x04 <- getInit(m4)
x02
x03
x01
clusterExport(cl,c("m1","m2","m3","m4",
"x01","x02","x03","x04"))
myParlfun3 <- function(vmin){  fit<-MCMC_CMR(m3,x0=x03*runif(m3$npar,min=0.9,max=1.1),niter=4e5,noblc = 100,                vmin=vmin,cvstp=diag(1e-3,m3$npar))}
myParlfun4 <- function(vmin){  fit<-MCMC_CMR(m4,x0=x04*runif(m4$npar,min=0.9,max=1.1),niter=4e5,noblc = 100,                vmin=vmin,cvstp=diag(1e-3,m4$npar))}
fitsL3 <- parLapply(cl,10^(seq(-8,-3,by=1)),myParlfun3)
fitsL4 <- parLapply(cl,10^(seq(-8,-3,by=1)),myParlfun4)
t <- sapply(1:6,function(ii){plot(fitsL4[[ii]],drawplot=FALSE)$SpecRates})
par(mfrow=c(2,3))
for (jj in 1:6){
boxplot(t(matrix(t[,jj],nrow=11)),log='y',ylab='Extrates')
}
summary(fitsL3[[3]])
summary(fitsL4[[3]])
bml3 <- sapply(1:6,function(ii){doBML(fitsL3[[ii]])$logBML})
bml4 <- sapply(1:6,function(ii){doBML(fitsL4[[ii]])$logBML})
bml3
bml4
bml2
bml1
checkchains(fitsL3[[4]])
checkchains(fitsL3[[6]])
checkchains(fitsL3[[5]])
bml3 <- sapply(1:6,function(ii){doBML(fitsL3[[ii]])$logBML})
bml3 <- sapply(1:4,function(ii){doBML(fitsL3[[ii]])$logBML})
bml3
bml1
bml1s <- sapply(1:6,function(ii){replicate(3,doBML(fitsL1[[ii]])$logBML)})
bml1a
bml1s
doBML
bml1s <- sapply(1:6,function(ii){replicate(10,doBML(fitsL1[[ii]],ndraws=1e3)$logBML)})
bml1a
bml1s
boxplot(bml1s)
bml2s <- sapply(1:6,function(ii){replicate(10,doBML(fitsL2[[ii]],ndraws=1e3)$logBML})
bml2s <- sapply(1:6,function(ii){replicate(10,doBML(fitsL2[[ii]],ndraws=1e3)$logBML)})
boxplot(bml2s)
boxplot(cbind(bml1s,bml2s))
bml3s <- sapply(1:4,function(ii){replicate(10,doBML(fitsL3[[ii]],ndraws=1e3)$logBML)})
bml4s <- sapply(1:6,function(ii){replicate(10,doBML(fitsL4[[ii]],ndraws=1e3)$logBML)})
boxplot(cbind(bml1s,bml2s,bml3s,bml4s))
dev.off()
boxplot(cbind(bml1s,bml2s,bml3s,bml4s))
bml1s <- sapply(1:6,function(ii){replicate(10,doBML(fitsL1[[ii]],ndraws=1e4)$logBML)})
bml2s <- sapply(1:6,function(ii){replicate(10,doBML(fitsL2[[ii]],ndraws=1e4)$logBML)})
bml3s <- sapply(1:4,function(ii){replicate(10,doBML(fitsL3[[ii]],ndraws=1e4)$logBML)})
bml4s <- sapply(1:6,function(ii){replicate(10,doBML(fitsL4[[ii]],ndraws=1e4)$logBML)})
boxplot(cbind(bml1s,bml2s,bml3s,bml4s))
summary(fitsL1[[1]])
summary(fitsL1[[4]])
summary(fitsL1[[2]])
summary(fitsL2[[2]])
summary(fitsL3[[2]])
summary(fitsL4[[2]])
set.seed(211080+2)
stages = GSA_timescale[GSA_timescale$scale_level==5,]
do = seq(90,8,by=-1)
# 90 to 8 is 'Phanerozoic'
stages[do,]$interval_name
drivers <- Proxies[do,] # not driver for last bin
dts = stages[do,]$max_ma-stages[do,]$min_ma
names(dts) <- stages[do,]$interval_name
Obs = (t(Occ_species>0))[,do]
Obs <- Obs[which(rowSums(Obs)>0),]
dim(Obs)
x0 <- getInits(m1)
# save.image('Phanero_test_30012020.RData')
x0 <- getInit(m1)
x0
Obs
dim(Obs
)
m1 <- make_BayesCMR(Obs,dts,spec=~time+div*SeaLev,ext = ~time,samp = ~time,data=drivers)
# save.image('Phanero_test_30012020.RData')
x0 <- getInit(m1)
x0
vms <- 10^(seq(-9,-4,by=1))
stopCluster(cl)
cl <- makeCluster(6)
clusterEvalQ(cl,library(Compadre))
clusterExport(cl,c("m1","x0"))
myParlfun1 <- function(vmin){
fit<-MCMC_CMR(m1,x0=x01*runif(m1$npar,min=0.9,max=1.1),niter=1e6,noblc = 100,
vmin=vmin,cvstp=diag(1e-3,m1$npar))}
fitsPhane <- parLapply(cl,10^(seq(-8,-3,by=1)),myParlfun1)
fit<-MCMC_CMR(m1,x0=x1*runif(m1$npar,min=0.9,max=1.1),niter=1e6,noblc = 100,
vmin=vmin,cvstp=diag(1e-3,m1$npar))}
fitsPhane <- parLapply(cl,10^(seq(-8,-3,by=1)),myParlfun1)
myParlfun1 <- function(vmin){
fit<-MCMC_CMR(m1,x0=x0*runif(m1$npar,min=0.9,max=1.1),niter=1e6,noblc = 100,
vmin=vmin,cvstp=diag(1e-3,m1$npar))}
fitsPhane <- parLapply(cl,10^(seq(-8,-3,by=1)),myParlfun1)
checkchains(fitsPhane[[1]])
checkchains(fitsPhane[[4]])
summary(fitsPhane[[1]])
summary(fitsPhane[[2]])
summary(fitsPhane[[3]])
summary(fitsPhane[[4]])
summary(fitsPhane[[1]])
fitsPhane <- parLapply(cl,10^(seq(-12,-7,length.out=5)),myParlfun1)
stopCluster(cl)
library(devtools)
setwd('C:/Users/josteist/Documents/R/Compadre')
document()
setwd('C:/Users/josteist/Documents/R')
install('Compadre')
library(Compadre)
