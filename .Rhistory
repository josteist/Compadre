X_Big[tix,]=x;
P_Big[tix] = p_now;
A_Big[tix] = tmpA;
tmpA = 0;
tix =tix+1;
setTxtProgressBar(prgb,ii/niter);
}
# show(p_now)
}
}
print(paste0('MCMC run finished at ', Sys.time()))
out <- list(Call = fullcall,Chain=X_Big,Probs=P_Big,Accept=A_Big,Model=cmrModel,Covs = cvstp,date=date())
attr(out,"class") <- "CMR_fit";
return(out)
}
f1 <- MCMC_CMR(m1,niter=1e3)#,x=runif(m1$npar,min=-0.01,max=0.02))
m1 <- make_BayesCMR_2clades(Obs1,Obs2,dts=dtsx)
f1 <- MCMC_CMR(m1,niter=1e3)#,x=runif(m1$npar,min=-0.01,max=0.02))
f1 <- MCMC_CMR(m1,niter=1e3)#,x=runif(m1$npar,min=-0.01,max=0.02))
f1 <- MCMC_CMR(m1,niter=1e3)#,x=runif(m1$npar,min=-0.01,max=0.02))
f1 <- MCMC_CMR(m1,niter=1e3)#,x=runif(m1$npar,min=-0.01,max=0.02))
library(devtools)
setwd("\Documents")
setwd("C:/Users/josteist/Documents/Compadre")
document()
document()
setwd("C:/Users/josteist/Documents/")
install('Compadre')
m1 <- make_BayesCMR_2clades(Obs1,Obs2,dts=dtsx)
f1 <- MCMC_CMR(m1,niter=1e3)#,x=runif(m1$npar,min=-0.01,max=0.02))
m1
m1$clade1inx
cmrModel = m1
if (is.null(cmrModel$clade1inx)){
# If this is null, then the model is for one clade only.
if (is.null(x0)){
# If no initial given, then optimize for main three parameters and use those as inits + only 0's
# c(-2,-2.2,-2.1,rep(0,cmrModel$npar-3))
x0 = c(optim(c(-1,-1.1,-1.2),function(x){-cmrModel$probfun(c(x[1],x[2],x[3],rep(0,cmrModel$npar-3)))})$par,
rep(0,cmrModel$npar-3))
}
} else {
# This is a two clade model.
if (is.null(x0)){
# If no initial given, then optimize for main three parameters and use those as inits + only 0's
# c(-2,-2.2,-2.1,rep(0,cmrModel$npar-3))
xtmp1<-optim(c(-1.1,-1.2,-1),function(x){-cmrModel$Clade1Mod$probfun(c(x[1],x[2],x[3],rep(0,cmrModel$Clade1Mod$npar-3)))})
xtmp2<-optim(c(-1.1,-1.2,-1),function(x){-cmrModel$Clade2Mod$probfun(c(x[1],x[2],x[3],rep(0,cmrModel$Clade1Mod$npar-3)))})
x0 = c(xtmp1,rep(0,cmrModel$Clade1Mod$npar-3),
xtmp2,rep(0,cmrModel$Clade2Mod$npar-3))
}
}
x0 = NULL
if (is.null(cmrModel$clade1inx)){
# If this is null, then the model is for one clade only.
if (is.null(x0)){
# If no initial given, then optimize for main three parameters and use those as inits + only 0's
# c(-2,-2.2,-2.1,rep(0,cmrModel$npar-3))
x0 = c(optim(c(-1,-1.1,-1.2),function(x){-cmrModel$probfun(c(x[1],x[2],x[3],rep(0,cmrModel$npar-3)))})$par,
rep(0,cmrModel$npar-3))
}
} else {
# This is a two clade model.
if (is.null(x0)){
# If no initial given, then optimize for main three parameters and use those as inits + only 0's
# c(-2,-2.2,-2.1,rep(0,cmrModel$npar-3))
xtmp1<-optim(c(-1.1,-1.2,-1),function(x){-cmrModel$Clade1Mod$probfun(c(x[1],x[2],x[3],rep(0,cmrModel$Clade1Mod$npar-3)))})
xtmp2<-optim(c(-1.1,-1.2,-1),function(x){-cmrModel$Clade2Mod$probfun(c(x[1],x[2],x[3],rep(0,cmrModel$Clade1Mod$npar-3)))})
x0 = c(xtmp1,rep(0,cmrModel$Clade1Mod$npar-3),
xtmp2,rep(0,cmrModel$Clade2Mod$npar-3))
}
}
x0
xtmp1
setwd("C:/Users/josteist/Documents/Compadre")
document()
setwd("C:/Users/josteist/Documents/")
install('Compadre')
m1 <- make_BayesCMR_2clades(Obs1,Obs2,dts=dtsx)
f1 <- MCMC_CMR(m1,niter=1e3)#,x=runif(m1$npar,min=-0.01,max=0.02))
library(Compadre)
m1 <- make_BayesCMR_2clades(Obs1,Obs2,dts=dtsx)
f1 <- MCMC_CMR(m1,niter=1e3)#,x=runif(m1$npar,min=-0.01,max=0.02))
m2 <- make_BayesCMR(Obs1,dtsx)
f2 <- MCMC_CMR(m2,niter=1e4)
plot(f2)
ESS(f2)
myESS(f2)
?ESS
ESS
rm(list=ls())
# Testing two interacting clades.
library(Compadre)
stages = GSA_timescale[GSA_timescale$scale_level==5,]
do = seq(90,8,by=-1)
stages[do,]$interval_name
dts = rev(stages$max_ma-stages$min_ma)[do]
Obs = (1*(InvertPBDB>0))[,do]
Obs <- Obs[which(rowSums(Obs)>0),]
dim(Obs)
plot(cumsum(dts),colSums(Obs>0),type="o")
Obs1 <- Obs[1:30000,30:50];
Obs2 <- Obs[30001:60000,30:50];
dtsx <- dts[30:50]
Obs1 <- Obs1[which(rowSums(Obs1)>0),]
Obs2 <- Obs2[which(rowSums(Obs2)>0),]
m1 <- make_BayesCMR_2clades(Obs1,Obs2,dts=dtsx)
m2 <- make_BayesCMR(Obs1,dtsx)
f1 <- MCMC_CMR(m1,niter=1e3)#,x=runif(m1$npar,min=-0.01,max=0.02))
f2 <- MCMC_CMR(m2,niter=1e4)
plot(f2)
f2
ESS(f2)
myESS(f2)
effectiveSize
library(devtools)
setwd("\Documents")
setwd("C:/Users/josteist/Documents/Compadre")
document()
setwd("C:/Users/josteist/Documents/")
install('Compadre')
library(Compadre)
m1 <- make_BayesCMR_2clades(Obs1,Obs2,dts=dtsx)
m2 <- make_BayesCMR(Obs1,dtsx)
f1 <- MCMC_CMR(m1,niter=1e3)#,x=runif(m1$npar,min=-0.01,max=0.02))
f2 <- MCMC_CMR(m2,niter=1e4)
ESS(f2)
ESS
?ESS
library(help='Compadre')
setwd("C:/Users/josteist/Documents/Compadre")
document()
install('Compadre')
setwd("C:/Users/josteist/Documents/")
install('Compadre')
library(Compadre)
m1 <- make_BayesCMR_2clades(Obs1,Obs2,dts=dtsx)
m2 <- make_BayesCMR(Obs1,dtsx)
f1 <- MCMC_CMR(m1,niter=1e3)#,x=runif(m1$npar,min=-0.01,max=0.02))
f2 <- MCMC_CMR(m2,niter=1e4)
ESS(f2)
ESS
?ESS
setwd("C:/Users/josteist/Documents/Compadre")
document()
setwd("C:/Users/josteist/Documents/")
install('Compadre')
ESS(f2)
?myESS
myESS
mcmc_Ess
library(help='Compadre')
mcmc_ESS(f2)
install('Compadre')
library(Compadre)
mcmc_ESS(f2)
mcmc_ESS(f2)
?mcmc_ESS
?coda
effectiveSize
setwd("C:/Users/josteist/Documents/")
setwd("C:/Users/josteist/Documents/Compadre")
document()
setwd("C:/Users/josteist/Documents/")
install('Compadre')
f2 <- MCMC_CMR(m2,niter=1e4)
mcmc_ESS(f2)
effectiveSize
coda::effectiveSize(f2$Chain)
setwd("C:/Users/josteist/Documents/Compadre")
document()
S
mcmc_ESS(f2)
ESS(f2)
setwd("C:/Users/josteist/Documents/Compadre")
document()
setwd("C:/Users/josteist/Documents/")
install('Compadre')
ESS(f2)
f2 <- MCMC_CMR(m2,niter=2e4)
ESS(f2)
m1 <- make_BayesCMR_2clades(Obs1,Obs2,dts=dtsx)
m2 <- make_BayesCMR(Obs1,dtsx)
f1 <- MCMC_CMR(m1,niter=1e3)#,x=runif(m1$npar,min=-0.01,max=0.02))
m1$probfun()
m1$npar
m1$probfun
m1$npar
m1$probfun(runif(138,min=-0.1,max=0.1))
MCMC_CMR <- function(cmrModel,niter=1e3,nthin=10,vmin=1e-5,
draweps=niter/100,
x0=NULL,
cvstp = (2.38/(sqrt(cmrModel$npar)))^2*diag(vmin,cmrModel$npar),
adapt=TRUE){
# Adaptive MCMC approach, tuning the stps to the covariance of the
# chain for the first half of the run.
# The covariance proposal is updated each draweps iteration the
# first half og the total niter [number of iterations.]
# _v2 should store all samples for each block(draweps), and use the samples from the last block
# only to update the cov. Then we need a temp_X which stores ALL samples for each block.
if (is.null(cmrModel$clade1inx)){
# If this is null, then the model is for one clade only.
if (is.null(x0)){
# If no initial given, then optimize for main three parameters and use those as inits + only 0's
# c(-2,-2.2,-2.1,rep(0,cmrModel$npar-3))
x0 = c(optim(c(-1,-1.1,-1.2),function(x){-cmrModel$probfun(c(x[1],x[2],x[3],rep(0,cmrModel$npar-3)))})$par,
rep(0,cmrModel$npar-3))
}
} else {
# This is a two clade model.
if (is.null(x0)){
# If no initial given, then optimize for main three parameters and use those as inits + only 0's
# c(-2,-2.2,-2.1,rep(0,cmrModel$npar-3))
xtmp1<-optim(c(-1.1,-1.2,-1),function(x){-cmrModel$Clade1Mod$probfun(c(x[1],x[2],x[3],rep(0,cmrModel$Clade1Mod$npar-3)))})$par
xtmp2<-optim(c(-1.1,-1.2,-1),function(x){-cmrModel$Clade2Mod$probfun(c(x[1],x[2],x[3],rep(0,cmrModel$Clade2Mod$npar-3)))})$par
x0 = c(xtmp1,rep(0,cmrModel$Clade1Mod$npar-3),
xtmp2,rep(0,cmrModel$Clade2Mod$npar-3))
}
}
fullcall <- deparse(match.call());
# print(fullcall)
print(paste0('MCMC run started at ', Sys.time()))
x=x0;
noblc = niter/draweps;
# Number of blocks; the whole chain is divided into blocks for faster computation. The proposal
# var/covariance matrix is updated in the first half of the MCMC chain at the end of each block.
stp <- niter/nthin # NOT USED?
p_now = cmrModel$probfun(x) # Model probability now.
X_Big = array(NA,c(ceiling(niter/nthin),cmrModel$npar)) # Large array for storing the parameter chains
P_Big = array(NA,c(ceiling(niter/nthin))); # Long array to store the model probabilities.
A_Big = array(NA,c(ceiling(niter/nthin))); # Long array to store the acceptance rates
X_Big[1,]=x; # Inputting the initial parameters
P_Big[1] = p_now; # and the initial model probability
tmp_X = array(NA,c(draweps,cmrModel$npar)); # Temporary array to store all samples here for each block.
# This is used to update the var/covar proposal matrix.
Acc = 0; # Counter for acceptance of proposals
prgb<- txtProgressBar(min=0,max=1,initial=0,style=3) # Print a progress bar.
ii = 1; # counter for all iterations. Used to update the progres bar.
tix = 1; # counter for the stored samples, i.e. for each nthin sample
# adapt = T; # TRUE/FALSE if the var/covar should be updated.
tmpA = 0;  # Temporary array to cound acceptances.
for (jj in 1:noblc){
if (jj>1 & adapt==T){
# Should augment this to be only
# cvstp <- (2.38/(sqrt(cmrModel$npar)))^2*(cov(X_Big[(tix-draweps/nthin):(tix-1),])  +
# diag(vmin,cmrModel$npar))
# 261018. Below the new cov is based on the last 'half' of the stored
# chain. This could be 'less', i.e. only using the cov based on the last
# fewer number of iterations. I guess it should actually be based on all
# samples the last n iterations, and not only the stored ones?
# old:
# cvstp <- (2.38/(sqrt(cmrModel$npar)))^2*(cov(X_Big[round(tix/2):(tix-1),])  +
# diag(vmin,cmrModel$npar))
cvstp <- (2.38/(sqrt(cmrModel$npar)))^2*(cov(tmp_X)  +
diag(vmin,cmrModel$npar))
# print(cvstp[1:4,1:4])
if (jj>(noblc/2)){
adapt=F;
}
}
epss <- mvtnorm::rmvnorm(draweps,sigma=cvstp)
for (ll in 1:draweps){
ii = ii+1;
p_new = cmrModel$probfun(x+epss[ll,])
if (runif(1)<exp(p_new-p_now)){
x = x+epss[ll,];
p_now = p_new;
Acc = Acc+1;
tmpA = tmpA+1;
}
tmp_X[ll,] = x;
if ((ii %% nthin)==0){
X_Big[tix,]=x;
P_Big[tix] = p_now;
A_Big[tix] = tmpA;
tmpA = 0;
tix =tix+1;
setTxtProgressBar(prgb,ii/niter);
}
# show(p_now)
}
}
print(paste0('MCMC run finished at ', Sys.time()))
out <- list(Call = fullcall,Chain=X_Big,Probs=P_Big,Accept=A_Big,Model=cmrModel,Covs = cvstp,date=date())
attr(out,"class") <- "CMR_fit";
return(out)
}
MCMC_CMR(m2)
MCMC_CMR(m1)
cmrMo
cmrModel
cmrModel <- m1
# If no initial given, then optimize for main three parameters and use those as inits + only 0's
# c(-2,-2.2,-2.1,rep(0,cmrModel$npar-3))
xtmp1<-optim(c(-1.1,-1.2,-1),function(x){-cmrModel$Clade1Mod$probfun(c(x[1],x[2],x[3],rep(0,cmrModel$Clade1Mod$npar-3)))})$par
xtmp2<-optim(c(-1.1,-1.2,-1),function(x){-cmrModel$Clade2Mod$probfun(c(x[1],x[2],x[3],rep(0,cmrModel$Clade2Mod$npar-3)))})$par
x0 = c(xtmp1,rep(0,cmrModel$Clade1Mod$npar-3),
xtmp2,rep(0,cmrModel$Clade2Mod$npar-3))
x0
length(x0)
cmrModel$npar
cmrModel$npar-cmrModel$Clade1Mod$npar
cmrModel$npar-cmrModel$Clade1Mod$npar - cmrModel$Clade2Mod$npar
setwd("C:/Users/josteist/Documents/Compadre")
document()
setwd("C:/Users/josteist/Documents/")
install('Compadre')
library(Compadre)
m1 <- make_BayesCMR_2clades(Obs1,Obs2,dts=dtsx)
f1 <- MCMC_CMR(m1,niter=1e3)#,x=runif(m1$npar,min=-0.01,max=0.02))
x0 = c(xtmp1,rep(0,cmrModel$Clade1Mod$npar-3),
xtmp2,rep(0,cmrModel$Clade2Mod$npar-3),
rep(0,cmrModel$npar-cmrModel$Clade1Mod$npar - cmrModel$Clade2Mod$npar))
x0
length(x0)
m1$probfun(x0)
f1 <- MCMC_CMR(m1,niter=1e4)#,x=runif(m1$npar,min=-0.01,max=0.02))
x0 = c(optim(c(-1,-1.1,-1.2),function(x){-cmrModel$probfun(c(x[1],x[2],x[3],rep(0,cmrModel$npar-3)))})$par,
rep(0,cmrModel$npar-3))
f1 <- Compadre::MCMC_CMR(m1,niter=1e4)#,x=runif(m1$npar,min=-0.01,max=0.02))
Obs1 <- Obs[1:30000,30:43];
Obs2 <- Obs[30001:60000,30:43];
dtsx <- dts[30:50]
Obs1 <- Obs1[which(rowSums(Obs1)>0),]
Obs2 <- Obs2[which(rowSums(Obs2)>0),]
m1 <- make_BayesCMR_2clades(Obs1,Obs2,dts=dtsx)
m2 <- make_BayesCMR(Obs1,dtsx)
dts = rev(stages$max_ma-stages$min_ma)[do]
m1 <- make_BayesCMR_2clades(Obs1,Obs2,dts=dtsx)
m2 <- make_BayesCMR(Obs1,dtsx)
dtsx
dim(Obs1)
dim(Obs2)
Obs1 <- Obs1[which(rowSums(Obs1)>0),]
Obs2 <- Obs2[which(rowSums(Obs2)>0),]
m1 <- make_BayesCMR_2clades(Obs1,Obs2,dts=dtsx)
length(dtsx)
dtsx <- dts[30:43]
m1 <- make_BayesCMR_2clades(Obs1,Obs2,dts=dtsx)
m2 <- make_BayesCMR(Obs1,dtsx)
mB <- make_BayesCMR_2clades(Obs1,Obs2,dts=dtsx)
m1 <- make_BayesCMR(Obs1,dtsx)
m2 <- make_BayesCMR(Obs2,dtsx)
f1 <- MCMC_CMR(m1,niter=5e4)#,x=runif(m1$npar,min=-0.01,max=0.02))
ESS(f1)
mcmc_ESS(f2)
setwd("C:/Users/josteist/Documents/Compadre")
document()
setwd("C:/Users/josteist/Documents/")
install('Compadre')
library(Compadre)
rm(list=ls())
library(Compadre)
stages = GSA_timescale[GSA_timescale$scale_level==5,]
do = seq(90,8,by=-1)
stages[do,]$interval_name
dts = rev(stages$max_ma-stages$min_ma)[do]
Obs = (1*(InvertPBDB>0))[,do]
Obs <- Obs[which(rowSums(Obs)>0),]
dim(Obs)
plot(cumsum(dts),colSums(Obs>0),type="o")
mx <- make_BayesCMR(Obs,dts)
fx <- MCMC_CMR(mx,niter=1e4)
plot(fx)
matplot(fx$Chain,type="l")
plot(fx)
ESS(fx)
fx <- MCMC_CMR(mx,niter=5e4)
ESS(fx)
plot(fx)
?polygon
fit = fx
d1 <- density(exp(fit$Chain[-c(1:dim(fit$Chain)[1]/2),1]),from=0)
d2 <- density(exp(fit$Chain[-c(1:dim(fit$Chain)[1]/2),2]),from=0)
d3 <- density(exp(fit$Chain[-c(1:dim(fit$Chain)[1]/2),3]),from=0)
plot(d1,col=rgb(0.1,0.1,0.8,0.6),
xlim=c(1e-5,ceiling(10*exp(max(fit$Chain[-c(1:dim(fit$Chain)[1]/2)])))/10),main='Macroevolutionary rates',ylab='',
xlab='Rate',yaxt='n',bty='n',
ylim=c(0,max(c(d1$y,d2$y,d3$y))))
polygon(c(1e-8,d1$x,1e-8),
c(1e-8,d1$y,1e-8),col=rgb(0.1,0.1,0.8,0.3),border=rgb(0.1,0.1,0.8,0.6))
polygon(c(1e-8,d2$x,1e-8),
c(1e-8,d2$y,1e-8),col=rgb(0.8,0.1,0.1,0.3),border=rgb(0.8,0.1,0.1,0.6))
polygon(c(1e-8,d3$x,1e-8),
c(1e-8,d3$y,1e-8),col=rgb(0.1,0.6,0.1,0.3),border=rgb(0.1,0.6,0.1,0.6))
polygon(c(1e-8,d1$x,1e8),
c(1e-8,d1$y,1e-8),col=rgb(0.1,0.1,0.8,0.3),border=rgb(0.1,0.1,0.8,0.6))
polygon(c(1e-8,d2$x,1e8),
c(1e-8,d2$y,1e-8),col=rgb(0.8,0.1,0.1,0.3),border=rgb(0.8,0.1,0.1,0.6))
polygon(c(1e-8,d3$x,1e8),
c(1e-8,d3$y,1e-8),col=rgb(0.1,0.6,0.1,0.3),border=rgb(0.1,0.6,0.1,0.6))
plot(d1,col=rgb(0.1,0.1,0.8,0.6),
xlim=c(1e-5,ceiling(10*exp(max(fit$Chain[-c(1:dim(fit$Chain)[1]/2)])))/10),main='Macroevolutionary rates',ylab='',
xlab='Rate',yaxt='n',bty='n',
ylim=c(0,max(c(d1$y,d2$y,d3$y))))
polygon(c(1e-8,d1$x,1e8),
c(1e-8,d1$y,1e-8),col=rgb(0.1,0.1,0.8,0.3),border=rgb(0.1,0.1,0.8,0.6))
polygon(c(1e-8,d2$x,1e8),
c(1e-8,d2$y,1e-8),col=rgb(0.8,0.1,0.1,0.3),border=rgb(0.8,0.1,0.1,0.6))
polygon(c(1e-8,d3$x,1e8),
c(1e-8,d3$y,1e-8),col=rgb(0.1,0.6,0.1,0.3),border=rgb(0.1,0.6,0.1,0.6))
Obs1 <- Obs[1:30000,30:43];
Obs2 <- Obs[30001:60000,30:43];
dtsx <- dts[30:43]
Obs1 <- Obs1[which(rowSums(Obs1)>0),]
Obs2 <- Obs2[which(rowSums(Obs2)>0),]
mB <- make_BayesCMR_2clades(Obs1,Obs2,dts=dtsx)
m1 <- make_BayesCMR(Obs1,dtsx)
m2 <- make_BayesCMR(Obs2,dtsx)
f1 <- MCMC_CMR(m1,niter=5e4)#,x=runif(m1$npar,min=-0.01,max=0.02))
ESS(f1)
f2 <- MCMC_CMR(m2,niter=5e4)
ESS(f2)
fB <- MCMC_CMR(mB,niter=1e5)
fB <- MCMC_CMR(mB,niter=1e3)
ESS(fB)
hist(ESS(fB))
plot(fB)
matplot(fB$Chain[,1:3],type="l")
matplot(fB$Chain[,10:13],type="l")
fb
fB
mB
setwd("C:/Users/josteist/Documents/Compadre")
document()
setwd("C:/Users/josteist/Documents/")
install('Compadre')
library(Compadre)
mB
typeof(mB)
setwd("C:/Users/josteist/Documents/Compadre")
document()
setwd("C:/Users/josteist/Documents/")
install('Compadre')
mB
mB <- make_BayesCMR_2clades(Obs1,Obs2,dts=dtsx)
mB
m1 <- make_BayesCMR(Obs1,dtsx)
m2 <- make_BayesCMR(Obs2,dtsx)
m1
mf2
m2
m1 <- make_BayesCMR(Obs1,dtsx,SpecTS = runif(length(dtsx),min=-2,max=2))
m1 <- make_BayesCMR(Obs1,dtsx,SpecTS = t(runif(length(dtsx)-1,min=-2,max=2)))
f1 <- MCMC_CMR(m1,niter=5e4)#,x=runif(m1$npar,min=-0.01,max=0.02))
m1
plot(f1)
m1$aix
plot(f1$Chain[,f1$Model$aix],type="l")
plot(f1$Chain[,unlist(f1$Model$aix)],type="l")
ESS(f1)
m1 <- make_BayesCMR(Obs1,dtsx,SpecTS = t(runif(length(dtsx)-1,min=-2,max=2)),RE=c(T,F,T))
f1 <- MCMC_CMR(m1,niter=5e4)#,x=runif(m1$npar,min=-0.01,max=0.02))
ESS(f1)
hist(ESS(f1))
matplot(f1$Chain[,1:3],type="l")
plot(f1)
f1
plot(f1$Chain[,4],type="l")
f1a <- contMCMC_CMR(f1,niter=1e5);
ESS(f1a)
matplot(f1a$Chain[,1:3],type="l")
matplot(f1a$Chain[,1:4],type="l")
f1 <- MCMC_CMR(m1,niter=1e5)#,x=runif(m1$npar,min=-0.01,max=0.02))
ESS(f1)
plot(f1)
matplot(f1$Chain[,1:4],type="l")
f1$Covs
f1 <- MCMC_CMR(m1,niter=4e5)#,x=runif(m1$npar,min=-0.01,max=0.02))
f1
plot(f1)
ESS(f1)
hist(ESS(f1))
matplot(f1$Chain[,1:3],type="l")
matplot(f1$Chain[,1:3],type="l")
matplot(f1$Chain[,4],type="l")
plot(density(f1$Chain[-c(1:20000),4]))
setwd("C:/Users/josteist/Documents/Compadre")
document()
setwd("C:/Users/josteist/Documents/Compadre")
document()
setwd("C:/Users/josteist/Documents/")
install('Compadre')
mB <- make_BayesCMR_2clades(Obs1,Obs2,dts=dtsx,
SpecTS1 = runif(length(dtsx)-1,min=-1,max=2,),
ExtTS2  = runif(length(dtsx)-1,min=0.1,max=0.3))
mB <- make_BayesCMR_2clades(Obs1,Obs2,dts=dtsx,
SpecTS1 = runif(length(dtsx)-1,min=-1,max=2),
ExtTS2  = runif(length(dtsx)-1,min=0.1,max=0.3))
length(dtsx)
dim(Obs1)
dim(OBs2)
dim(Obs2)
runif(length(dtsx)-1,min=-1,max=2)
mB <- make_BayesCMR_2clades(Obs1,Obs2,dts=dtsx,
SpecTS1 = t(runif(length(dtsx)-1,min=-1,max=2)),
ExtTS2  = t(runif(length(dtsx)-1,min=0.1,max=0.3)))
mB$Clade1Mod$aix
mB$Clade2Mod$aix
mB$clade1inx
mB$clade2inx
fB <- MCMC_CMR(mB,niter=1e3)
ESS(fB)
matplot(fB$Chain[,1:3],type="l")
matplot(fB$Chain[,mB$clade1inx[1:3]],type="l")
matplot(fB$Chain[,mB$clade2inx[1:3]],type="l")
setwd("C:/Users/josteist/Documents/Compadre")
document()
setwd("C:/Users/josteist/Documents/Compadre")
document()
library(help='Compadre')
?make_BayesCMR_2clades
